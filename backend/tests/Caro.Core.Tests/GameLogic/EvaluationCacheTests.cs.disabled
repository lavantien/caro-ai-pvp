using Caro.Core.Domain.Entities;
using Caro.Core.GameLogic;
using Xunit;

namespace Caro.Core.Tests.GameLogic;

public class EvaluationCacheTests
{
    [Fact]
    public void MissReturnsStatic_ReturnsStaticEvaluationWhenCacheMiss()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        var board = new Board();
        int staticEval = 100;

        // Act
        int result = cache.GetCorrectedEvaluation(board.GetHash(), staticEval, depth: 1);

        // Assert - On cache miss, should return static evaluation unchanged
        Assert.Equal(staticEval, result);
    }

    [Fact]
    public void Update_AppliesCorrection_CacheAppliesCorrectionToStaticEval()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        var board = new Board();
        ulong hash = board.GetHash();
        int staticEval = 100;
        int searchResult = 150; // Search found better position

        // Act - Update cache with search result
        cache.Update(hash, staticEval, searchResult, depth: 3);
        int corrected = cache.GetCorrectedEvaluation(hash, staticEval, depth: 1);

        // Assert - Corrected eval should be closer to search result
        // Formula: corrected = staticEval + (searchResult - staticEval) * decayFactor
        // For depth 3, decayFactor = 0.5 (roughly), so: 100 + (150-100) * 0.5 = 125
        Assert.InRange(corrected, Math.Min(staticEval, searchResult), Math.Max(staticEval, searchResult));
        Assert.NotEqual(staticEval, corrected);
    }

    [Fact]
    public void BoundsChecking_CorrectedValuesStayWithinValidBounds()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        var board = new Board();

        // Test extreme values
        int staticEval = 0;
        int extremeSearchResult = 1000000; // Very high score

        // Act
        cache.Update(board.GetHash(), staticEval, extremeSearchResult, depth: 5);
        int corrected = cache.GetCorrectedEvaluation(board.GetHash(), staticEval, depth: 1);

        // Assert - Should be bounded to reasonable limits
        Assert.InRange(corrected, -200000, 200000);
    }

    [Fact]
    public void DepthCheck_ShallowerCacheNotUsedForDeepSearch()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        ulong hash = 12345ul;
        int staticEval = 100;
        int shallowSearchResult = 120;

        // Store at depth 2
        cache.Update(hash, staticEval, shallowSearchResult, depth: 2);

        // Lookup at depth 5 (deeper than cached)
        int result = cache.GetCorrectedEvaluation(hash, staticEval, depth: 5);

        // Assert - Should return static eval since cache is shallower than lookup depth
        Assert.Equal(staticEval, result);
    }

    [Fact]
    public void DepthCheck_DeeperCacheUsedForShallowLookup()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        ulong hash = 12345ul;
        int staticEval = 100;
        int deepSearchResult = 150;

        // Store at depth 6
        cache.Update(hash, staticEval, deepSearchResult, depth: 6);

        // Lookup at depth 3 (shallower than cached)
        int result = cache.GetCorrectedEvaluation(hash, staticEval, depth: 3);

        // Assert - Should use cached deep result
        Assert.NotEqual(staticEval, result);
    }

    [Fact]
    public void AgeBasedReplacement_OlderEntriesReplacedFirst()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);

        // Fill cache with entries at age 0
        for (int i = 0; i < 1000; i++)
        {
            cache.Update((ulong)i, 100, 150, depth: 3);
        }

        // Increment age (making existing entries old)
        cache.IncrementAge();

        // Add new entry - should replace an old one
        cache.NewEntry(99999ul, 100, 150, depth: 3);

        // The new entry should be retrievable
        int result = cache.GetCorrectedEvaluation(99999ul, 100, depth: 1);
        Assert.NotEqual(100, result);
    }

    [Fact]
    public void Update_ReplacesExistingEntry_SameHashDeeperDepth()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        ulong hash = 12345ul;
        int staticEval = 100;

        // Store at depth 2
        cache.Update(hash, staticEval, 120, depth: 2);

        // Store at depth 5 (should replace)
        cache.Update(hash, staticEval, 150, depth: 5);

        // Lookup should return corrected value from deeper entry
        int result = cache.GetCorrectedEvaluation(hash, staticEval, depth: 3);
        Assert.NotEqual(staticEval, result);
    }

    [Fact]
    public void Clear_EmptiesCache()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        cache.Update(12345ul, 100, 150, depth: 3);

        // Act
        cache.Clear();

        // Assert - Should return static eval (cache miss)
        int result = cache.GetCorrectedEvaluation(12345ul, 100, depth: 1);
        Assert.Equal(100, result);
    }

    [Fact]
    public void GetStats_ReturnsUsageStatistics()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        cache.Update(12345ul, 100, 150, depth: 3);
        cache.Update(23456ul, 100, 150, depth: 3);

        // Act
        var (hits, misses, hitRate) = cache.GetStats();

        // Assert
        Assert.Equal(0, hits); // No lookups yet
        Assert.Equal(0, misses);
        Assert.Equal(0.0, hitRate);
    }

    [Fact]
    public void MultipleLookups_UpdatesHitRateCorrectly()
    {
        // Arrange
        var cache = new EvaluationCache(sizeMB: 1);
        ulong hash = 12345ul;
        int staticEval = 100;

        // Store an entry
        cache.Update(hash, staticEval, 150, depth: 5);

        // Act - Multiple lookups
        cache.GetCorrectedEvaluation(hash, staticEval, depth: 3); // Hit
        cache.GetCorrectedEvaluation(54321ul, staticEval, depth: 1); // Miss
        cache.GetCorrectedEvaluation(hash, staticEval, depth: 1); // Hit

        // Assert
        var (hits, misses, hitRate) = cache.GetStats();
        Assert.Equal(2, hits);
        Assert.Equal(1, misses);
        Assert.Equal(2.0 / 3.0, hitRate, precision: 2);
    }
}
